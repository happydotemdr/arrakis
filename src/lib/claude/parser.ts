/**
 * Claude Code transcript parser
 * Parses JSONL transcript files generated by Claude Code
 */

import { readFile } from 'fs/promises'
import { existsSync } from 'fs'
import type {
  AnyTranscriptEntry,
  TranscriptMessage,
  TranscriptToolUse,
  TranscriptToolResult,
  TranscriptSystem,
  TranscriptError,
  ParsedConversation,
  ParsedMessage,
  ParsedToolUse,
} from './types'

/**
 * Parse a JSONL transcript file
 */
export async function parseTranscriptFile(
  filePath: string,
): Promise<ParsedConversation | null> {
  try {
    if (!existsSync(filePath)) {
      console.warn(`Transcript file not found: ${filePath}`)
      return null
    }

    const content = await readFile(filePath, 'utf-8')
    return parseTranscriptContent(content)
  } catch (error) {
    console.error(`Error reading transcript file ${filePath}:`, error)
    throw error
  }
}

/**
 * Parse transcript content from JSONL string
 */
export function parseTranscriptContent(
  content: string,
): ParsedConversation | null {
  try {
    const lines = content
      .trim()
      .split('\n')
      .filter((line) => line.trim())

    if (lines.length === 0) {
      return null
    }

    const entries: AnyTranscriptEntry[] = lines.map((line) => {
      try {
        return JSON.parse(line) as AnyTranscriptEntry
      } catch (error) {
        console.warn(`Failed to parse transcript line: ${line}`, error)
        return {
          type: 'error',
          timestamp: new Date().toISOString(),
          data: {
            message: 'Failed to parse transcript line',
            originalLine: line,
          },
        } as TranscriptError
      }
    })

    return parseTranscriptEntries(entries)
  } catch (error) {
    console.error('Error parsing transcript content:', error)
    throw error
  }
}

/**
 * Parse array of transcript entries into structured conversation
 */
export function parseTranscriptEntries(
  entries: AnyTranscriptEntry[],
): ParsedConversation {
  const messages: ParsedMessage[] = []
  const toolUses: ParsedToolUse[] = []
  const metadata: Record<string, any> = {}

  let sessionId: string | undefined
  let projectPath: string | undefined
  let startedAt = new Date()
  let endedAt: Date | undefined

  // Track tool uses by ID to match with results
  const pendingToolUses = new Map<string, Partial<ParsedToolUse>>()

  for (const entry of entries) {
    try {
      switch (entry.type) {
        case 'system':
          handleSystemEntry(entry, {
            setSessionId: (id) => (sessionId = id),
            setProjectPath: (path) => (projectPath = path),
            setStartedAt: (date) => (startedAt = date),
            setEndedAt: (date) => (endedAt = date),
            addMetadata: (key, value) => (metadata[key] = value),
          })
          break

        case 'message':
          const parsedMessage = parseMessageEntry(entry)
          if (parsedMessage) {
            messages.push(parsedMessage)
          }
          break

        case 'tool_use':
          const toolUse = parseToolUseEntry(entry)
          if (toolUse) {
            pendingToolUses.set(entry.data.id, toolUse)
          }
          break

        case 'tool_result':
          handleToolResultEntry(entry, pendingToolUses, toolUses)
          break

        case 'error':
          console.warn('Transcript contains error entry:', entry.data)
          metadata.errors = metadata.errors || []
          metadata.errors.push({
            timestamp: entry.timestamp,
            message: entry.data.message,
            code: entry.data.code,
          })
          break

        default:
          console.warn('Unknown transcript entry type:', entry)
      }
    } catch (error) {
      console.warn('Error processing transcript entry:', entry, error)
    }
  }

  // Add any remaining pending tool uses (without results)
  for (const [id, toolUse] of pendingToolUses) {
    if (toolUse.toolName) {
      toolUses.push({
        ...toolUse,
        status: 'timeout',
        error: 'No result received',
      } as ParsedToolUse)
    }
  }

  // If no explicit end time, use the timestamp of the last entry
  if (!endedAt && entries.length > 0) {
    const lastEntry = entries[entries.length - 1]
    endedAt = new Date(lastEntry.timestamp)
  }

  return {
    sessionId,
    projectPath,
    startedAt,
    endedAt,
    messages: messages.sort(
      (a, b) => a.timestamp.getTime() - b.timestamp.getTime(),
    ),
    toolUses: toolUses.sort(
      (a, b) => a.timestamp.getTime() - b.timestamp.getTime(),
    ),
    metadata,
  }
}

/**
 * Handle system entries (session info, metadata)
 */
function handleSystemEntry(
  entry: TranscriptSystem,
  handlers: {
    setSessionId: (id: string) => void
    setProjectPath: (path: string) => void
    setStartedAt: (date: Date) => void
    setEndedAt: (date: Date) => void
    addMetadata: (key: string, value: any) => void
  },
) {
  const { data } = entry

  if (data.sessionId) {
    handlers.setSessionId(data.sessionId)
  }

  if (data.projectPath) {
    handlers.setProjectPath(data.projectPath)
  }

  if (data.event === 'session_start') {
    handlers.setStartedAt(new Date(entry.timestamp))
    if (data.userInfo) {
      handlers.addMetadata('userInfo', data.userInfo)
    }
  }

  if (data.event === 'session_end') {
    handlers.setEndedAt(new Date(entry.timestamp))
    if (data.duration) {
      handlers.addMetadata('duration', data.duration)
    }
    if (data.messageCount) {
      handlers.addMetadata('messageCount', data.messageCount)
    }
    if (data.toolUseCount) {
      handlers.addMetadata('toolUseCount', data.toolUseCount)
    }
  }

  // Store other system data as metadata
  Object.keys(data).forEach((key) => {
    if (!['event', 'sessionId', 'projectPath'].includes(key)) {
      handlers.addMetadata(`system.${key}`, data[key])
    }
  })
}

/**
 * Parse message entry
 */
function parseMessageEntry(entry: TranscriptMessage): ParsedMessage | null {
  try {
    const { data } = entry
    let content = ''
    let toolCalls: any[] = []

    // Handle different content formats
    if (typeof data.content === 'string') {
      content = data.content
    } else if (Array.isArray(data.content)) {
      // Handle message content blocks
      const textBlocks = data.content
        .filter((block) => block.type === 'text')
        .map((block) => block.text || '')

      content = textBlocks.join('\n')

      // Extract tool calls
      toolCalls = data.content
        .filter((block) => block.type === 'tool_use')
        .map((block) => ({
          id: block.tool_use_id,
          name: block.name,
          input: block.input,
        }))
    }

    // Skip empty messages
    if (!content.trim() && toolCalls.length === 0) {
      return null
    }

    return {
      role: mapRole(data.role),
      content,
      timestamp: new Date(entry.timestamp),
      messageIndex: data.messageIndex,
      toolCalls: toolCalls.length > 0 ? toolCalls : undefined,
      metadata: {
        originalRole: data.role,
        id: data.id,
      },
    }
  } catch (error) {
    console.warn('Error parsing message entry:', entry, error)
    return null
  }
}

/**
 * Parse tool use entry
 */
function parseToolUseEntry(entry: TranscriptToolUse): Partial<ParsedToolUse> {
  return {
    toolName: entry.data.name,
    parameters: entry.data.input || {},
    timestamp: new Date(entry.timestamp),
    messageIndex: entry.data.messageIndex,
    status: 'success', // Will be updated when result is processed
    metadata: {
      toolUseId: entry.data.id,
    },
  }
}

/**
 * Handle tool result entry
 */
function handleToolResultEntry(
  entry: TranscriptToolResult,
  pendingToolUses: Map<string, Partial<ParsedToolUse>>,
  completedToolUses: ParsedToolUse[],
) {
  const toolUse = pendingToolUses.get(entry.data.tool_use_id)
  if (!toolUse) {
    console.warn(
      `Tool result received for unknown tool use: ${entry.data.tool_use_id}`,
    )
    return
  }

  const completedToolUse: ParsedToolUse = {
    ...toolUse,
    response: entry.data.content,
    status: entry.data.is_error ? 'error' : 'success',
    duration: entry.data.duration,
    error: entry.data.is_error ? String(entry.data.content) : undefined,
    metadata: {
      ...toolUse.metadata,
      resultTimestamp: entry.timestamp,
    },
  } as ParsedToolUse

  completedToolUses.push(completedToolUse)
  pendingToolUses.delete(entry.data.tool_use_id)
}

/**
 * Map Claude roles to our standard roles
 */
function mapRole(
  role: string,
): 'user' | 'assistant' | 'system' | 'function' | 'tool' {
  switch (role.toLowerCase()) {
    case 'human':
    case 'user':
      return 'user'
    case 'assistant':
    case 'ai':
      return 'assistant'
    case 'system':
      return 'system'
    case 'function':
      return 'function'
    case 'tool':
      return 'tool'
    default:
      console.warn(`Unknown role: ${role}, defaulting to 'user'`)
      return 'user'
  }
}

/**
 * Generate conversation title from messages
 */
export function generateConversationTitle(
  messages: ParsedMessage[],
  maxLength = 50,
): string {
  // Find the first user message
  const firstUserMessage = messages.find((m) => m.role === 'user')
  if (!firstUserMessage) {
    return 'Claude Code Conversation'
  }

  const content = firstUserMessage.content.trim()
  if (content.length <= maxLength) {
    return content
  }

  // Truncate at word boundary
  const truncated = content.substring(0, maxLength)
  const lastSpace = truncated.lastIndexOf(' ')
  if (lastSpace > maxLength * 0.8) {
    return truncated.substring(0, lastSpace) + '...'
  }

  return truncated + '...'
}

/**
 * Extract project name from project path
 */
export function extractProjectName(projectPath?: string): string | undefined {
  if (!projectPath) return undefined

  const parts = projectPath.replace(/\\/g, '/').split('/')
  return parts[parts.length - 1] || undefined
}

/**
 * Validate transcript file format
 */
export function validateTranscriptFile(content: string): boolean {
  try {
    const lines = content.trim().split('\n').filter((line) => line.trim())

    if (lines.length === 0) {
      return false
    }

    // Try to parse first few lines
    for (let i = 0; i < Math.min(3, lines.length); i++) {
      const parsed = JSON.parse(lines[i])
      if (!parsed.type || !parsed.timestamp) {
        return false
      }
    }

    return true
  } catch {
    return false
  }
}